<!DOCTYPE html>
<html>
<head>
  <title>PC Nest Speaker - WebRTC Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #334E58; overflow: hidden; }

    /* Ambient video background - fullscreen, behind everything */
    #ambient-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1;
      opacity: 0;
      transition: opacity 2s ease-in-out;
    }
    #ambient-video.visible { opacity: 1; }

    /* Gradient overlay for text readability */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(
        to bottom,
        rgba(51, 78, 88, 0.3) 0%,
        rgba(51, 78, 88, 0.1) 50%,
        rgba(51, 78, 88, 0.5) 100%
      );
      z-index: 2;
      pointer-events: none;
    }

    /* Status text */
    #status {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      color: #FCBFB7;
      font-family: 'Segoe UI', sans-serif;
      font-size: 28px;
      font-weight: 300;
      text-align: center;
      z-index: 10;
      text-shadow: 0 2px 20px rgba(0,0,0,0.5);
      padding: 12px 30px;
      background: rgba(51, 78, 88, 0.6);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    /* App branding - top left */
    #branding {
      position: fixed;
      top: 30px;
      left: 40px;
      color: rgba(252, 191, 183, 0.8);
      font-family: 'Segoe UI', sans-serif;
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 2px;
      z-index: 10;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    /* Audio visualizer dots */
    #visualizer {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    .viz-dot {
      width: 8px;
      height: 8px;
      background: #FCBFB7;
      border-radius: 50%;
      opacity: 0.6;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .viz-dot:nth-child(1) { animation-delay: 0s; }
    .viz-dot:nth-child(2) { animation-delay: 0.2s; }
    .viz-dot:nth-child(3) { animation-delay: 0.4s; }
    .viz-dot:nth-child(4) { animation-delay: 0.6s; }
    .viz-dot:nth-child(5) { animation-delay: 0.8s; }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.4; }
      50% { transform: scale(1.5); opacity: 1; }
    }

    /* Hide default cast player */
    #player { display: none; }
  </style>
</head>
<body>
  <cast-media-player id="player"></cast-media-player>

  <!-- Ambient video background -->
  <video id="ambient-video" muted loop playsinline></video>
  <div id="overlay"></div>

  <!-- UI elements -->
  <div id="branding">PC NEST SPEAKER</div>
  <div id="visualizer">
    <div class="viz-dot"></div>
    <div class="viz-dot"></div>
    <div class="viz-dot"></div>
    <div class="viz-dot"></div>
    <div class="viz-dot"></div>
  </div>
  <div id="status">Waiting for connection...</div>

  <!-- WebRTC audio element (invisible) -->
  <audio id="webrtc-audio" autoplay></audio>

  <script>
    const WEBRTC_NAMESPACE = 'urn:x-cast:com.pcnestspeaker.webrtc';

    // ===================
    // Ambient Video System - Free videos from Mixkit.co
    // ===================
    const ambientVideos = [
      // Ocean & Water
      'https://assets.mixkit.co/videos/48525/48525-4k.mp4',  // Aerial wave crashing onto shore
      'https://assets.mixkit.co/videos/44392/44392-4k.mp4',  // Flying low over the sea
      'https://assets.mixkit.co/videos/1954/1954-4k.mp4',    // Sea waves in a little bay

      // Clouds & Sky
      'https://assets.mixkit.co/videos/51105/51105-4k.mp4',  // White clouds moving quickly
      'https://assets.mixkit.co/videos/4695/4695-4k.mp4',    // Clouds covering mountains
      'https://assets.mixkit.co/videos/4132/4132-4k.mp4',    // Alps timelapse with clouds

      // Sunset & Landscapes
      'https://assets.mixkit.co/videos/2168/2168-4k.mp4',    // Bright orange sunset on beach
      'https://assets.mixkit.co/videos/4119/4119-4k.mp4',    // Stunning sunset from the sea
      'https://assets.mixkit.co/videos/3128/3128-4k.mp4',    // Mountains and sunset landscape
      'https://assets.mixkit.co/videos/4998/4998-4k.mp4',    // Large lake sunset aerial

      // Forest & Nature
      'https://assets.mixkit.co/videos/50847/50847-4k.mp4',  // Tranquil forest sunny day
      'https://assets.mixkit.co/videos/2213/2213-4k.mp4',    // Waterfall in forest
      'https://assets.mixkit.co/videos/41545/41545-4k.mp4',  // Flying over tree-covered mountains

      // Mountains
      'https://assets.mixkit.co/videos/4396/4396-4k.mp4',    // Fog on snowy mountains
      'https://assets.mixkit.co/videos/4283/4283-4k.mp4',    // Swiss Alps snow timelapse
      'https://assets.mixkit.co/videos/4281/4281-4k.mp4',    // Matterhorn landscape
      'https://assets.mixkit.co/videos/4366/4366-4k.mp4',    // Mountain range landscape

      // Space & Stars
      'https://assets.mixkit.co/videos/1610/1610-4k.mp4',    // Stars in space background
      'https://assets.mixkit.co/videos/14468/14468-4k.mp4',  // Star shower timelapse
      'https://assets.mixkit.co/videos/4148/4148-4k.mp4',    // Milky way at night
      'https://assets.mixkit.co/videos/29351/29351-4k.mp4',  // Earth slowly spinning

      // Underwater & Fish
      'https://assets.mixkit.co/videos/12816/12816-4k.mp4',  // Diving through a reef
      'https://assets.mixkit.co/videos/44868/44868-4k.mp4',  // Beautiful coral reef with fish
      'https://assets.mixkit.co/videos/4291/4291-4k.mp4',    // School of fish swimming
      'https://assets.mixkit.co/videos/7255/7255-4k.mp4',    // Clown fish and sea anemone
      'https://assets.mixkit.co/videos/4133/4133-4k.mp4',    // Dolphins underwater
      'https://assets.mixkit.co/videos/17950/17950-4k.mp4',  // Lion fish swimming

      // Animals
      'https://assets.mixkit.co/videos/4681/4681-4k.mp4',    // Flamingos on lake shore
      'https://assets.mixkit.co/videos/4285/4285-4k.mp4',    // Camels walking in desert
      'https://assets.mixkit.co/videos/4682/4682-4k.mp4',    // Swans swimming on river

      // Driving & Roads
      'https://assets.mixkit.co/videos/45312/45312-4k.mp4',  // Driving through forest bendy road
      'https://assets.mixkit.co/videos/52450/52450-4k.mp4',  // Curvy asphalt road sunny day
      'https://assets.mixkit.co/videos/45257/45257-4k.mp4',  // View from car beside mountain
      'https://assets.mixkit.co/videos/47629/47629-4k.mp4',  // Driving fast through tunnel

      // Rain & Weather
      'https://assets.mixkit.co/videos/25375/25375-4k.mp4',  // Soft rain and sunshine
      'https://assets.mixkit.co/videos/6890/6890-4k.mp4',    // Forest under tropical rain
      'https://assets.mixkit.co/videos/2846/2846-4k.mp4',    // Window on a rainy day
      'https://assets.mixkit.co/videos/18312/18312-4k.mp4',  // Rain falling on lake water

      // Fire & Flames
      'https://assets.mixkit.co/videos/1243/1243-4k.mp4',    // Wood burning in outdoor fire
      'https://assets.mixkit.co/videos/45676/45676-4k.mp4',  // Bonfire flames against black
      'https://assets.mixkit.co/videos/4426/4426-4k.mp4',    // Burning lava particles

      // Flowers & Gardens
      'https://assets.mixkit.co/videos/1168/1168-4k.mp4',    // Pink flowers in the breeze
      'https://assets.mixkit.co/videos/1187/1187-4k.mp4',    // White flowers in the breeze
      'https://assets.mixkit.co/videos/4881/4881-4k.mp4',    // Sunflower field sunny day
      'https://assets.mixkit.co/videos/4075/4075-4k.mp4',    // Countryside meadow
    ];

    let currentVideoIndex = 0;
    const ambientVideo = document.getElementById('ambient-video');

    function loadNextAmbientVideo() {
      // Fade out current video
      ambientVideo.classList.remove('visible');

      setTimeout(() => {
        // Pick next video (random or sequential)
        currentVideoIndex = Math.floor(Math.random() * ambientVideos.length);
        ambientVideo.src = ambientVideos[currentVideoIndex];
        ambientVideo.load();
      }, 1000); // Wait for fade out
    }

    ambientVideo.addEventListener('loadeddata', () => {
      console.log('[Ambient] Video loaded, playing...');
      ambientVideo.play().then(() => {
        ambientVideo.classList.add('visible');
      }).catch(e => console.log('[Ambient] Autoplay blocked:', e.message));
    });

    ambientVideo.addEventListener('ended', () => {
      console.log('[Ambient] Video ended, loading next...');
      loadNextAmbientVideo();
    });

    ambientVideo.addEventListener('error', (e) => {
      console.log('[Ambient] Video error, trying next...');
      loadNextAmbientVideo();
    });

    // Start first ambient video
    function startAmbientVideos() {
      console.log('[Ambient] Starting ambient video playlist');
      currentVideoIndex = Math.floor(Math.random() * ambientVideos.length);
      ambientVideo.src = ambientVideos[currentVideoIndex];
      ambientVideo.load();
    }

    // ===================
    // Cast Framework Setup
    // ===================
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const playbackConfig = new cast.framework.PlaybackConfig();

    // Low latency settings for HTTP fallback
    playbackConfig.autoResumeDuration = 0;
    playbackConfig.autoPauseDuration = 0;
    playbackConfig.initialBandwidth = 100000000;
    playbackConfig.disablePreload = true;
    playbackConfig.autoResumeNumberOfSegments = 0;
    playbackConfig.shakaConfig = {
      streaming: {
        bufferingGoal: 0.1,
        rebufferingGoal: 0,
        bufferBehind: 0,
        lowLatencyMode: true,
        segmentPrefetchLimit: 0,
        retryParameters: { maxAttempts: 1, timeout: 1000 }
      }
    };

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.PRELOAD,
      () => null
    );

    playerManager.setPlaybackConfig(playbackConfig);

    // ===================
    // WebRTC via MediaMTX WHEP
    // ===================
    let peerConnection = null;
    let whepResourceUrl = null;
    const audioElement = document.getElementById('webrtc-audio');

    function log(msg) {
      console.log('[WebRTC] ' + msg);
      document.getElementById('status').textContent = msg;
    }

    function hideDefaultPlayer() {
      const player = document.getElementById('player');
      if (player) player.style.display = 'none';
    }

    async function connectToMediaMTX(serverUrl, streamName = 'pcaudio') {
      log('Connecting...');

      // Start ambient videos when connecting
      startAmbientVideos();

      const iceConfig = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      };

      peerConnection = new RTCPeerConnection(iceConfig);

      peerConnection.ontrack = (event) => {
        console.log('[WebRTC] Track received:', event.track.kind);

        if (event.track.kind === 'audio') {
          if (event.streams && event.streams[0]) {
            audioElement.srcObject = event.streams[0];

            audioElement.muted = false;
            audioElement.volume = 1.0;

            audioElement.play().then(() => {
              log('Streaming audio...');
            }).catch(e => {
              audioElement.muted = true;
              audioElement.play().then(() => {
                setTimeout(() => {
                  audioElement.muted = false;
                  log('Streaming audio...');
                }, 100);
              }).catch(e2 => log('Play failed'));
            });
          } else {
            const stream = new MediaStream([event.track]);
            audioElement.srcObject = stream;
            audioElement.play().catch(e => log('Play error'));
          }
        }
      };

      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log('[WebRTC] Connection state:', state);
        if (state === 'connected') {
          log('Streaming audio...');
        } else if (state === 'failed') {
          log('Reconnecting...');
          setTimeout(() => {
            disconnect();
            connectToMediaMTX(serverUrl, streamName);
          }, 3000);
        }
      };

      peerConnection.addTransceiver('audio', { direction: 'recvonly' });

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await new Promise((resolve) => {
        if (peerConnection.iceGatheringState === 'complete') {
          resolve();
        } else {
          const checkState = () => {
            if (peerConnection.iceGatheringState === 'complete') {
              peerConnection.removeEventListener('icegatheringstatechange', checkState);
              resolve();
            }
          };
          peerConnection.addEventListener('icegatheringstatechange', checkState);
          setTimeout(resolve, 2000);
        }
      });

      const whepUrl = serverUrl + '/' + streamName + '/whep';
      console.log('[WebRTC] WHEP URL:', whepUrl);

      try {
        const response = await fetch(whepUrl, {
          method: 'POST',
          mode: 'cors',
          headers: { 'Content-Type': 'application/sdp' },
          body: peerConnection.localDescription.sdp
        });

        if (!response.ok) {
          throw new Error('WHEP error ' + response.status);
        }

        const location = response.headers.get('Location');
        if (location) {
          whepResourceUrl = location.startsWith('/') ? serverUrl + location : location;
        }

        const answerSdp = await response.text();
        await peerConnection.setRemoteDescription({ type: 'answer', sdp: answerSdp });

      } catch (e) {
        log('Connection error');
        console.error('[WebRTC] Error:', e);
      }
    }

    function disconnect() {
      if (peerConnection) {
        if (whepResourceUrl) {
          fetch(whepResourceUrl, { method: 'DELETE' }).catch(() => {});
          whepResourceUrl = null;
        }
        peerConnection.close();
        peerConnection = null;
        audioElement.srcObject = null;
        log('Disconnected');
      }
    }

    function handleMessage(event) {
      console.log('[Cast] Message:', event.data);
      const data = event.data;

      switch (data.type) {
        case 'connect':
          if (data.url) {
            connectToMediaMTX(data.url, data.stream || 'pcaudio');
          }
          break;
        case 'disconnect':
        case 'close':
          disconnect();
          break;
      }
    }

    context.addCustomMessageListener(WEBRTC_NAMESPACE, handleMessage);

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (request) => {
        if (request.media && request.media.contentId) {
          const contentId = request.media.contentId;

          if (contentId.startsWith('webrtc://')) {
            const httpsUrl = contentId.replace('webrtc://', '');
            hideDefaultPlayer();
            connectToMediaMTX(httpsUrl, 'pcaudio');
            return null;
          }
        }

        if (request.media && request.media.customData && request.media.customData.webrtcUrl) {
          connectToMediaMTX(request.media.customData.webrtcUrl, request.media.customData.stream || 'pcaudio');
          return null;
        }

        if (request.customData && request.customData.webrtcUrl) {
          connectToMediaMTX(request.customData.webrtcUrl, request.customData.stream || 'pcaudio');
          return null;
        }

        if (request.media) {
          request.media.streamType = cast.framework.messages.StreamType.LIVE;
          request.autoplay = true;
          request.currentTime = 0;
        }
        return request;
      }
    );

    context.start({
      playbackConfig: playbackConfig,
      skipPlayersLoad: false,
      disableIdleTimeout: true,
      supportedCommands: cast.framework.messages.Command.ALL_BASIC_MEDIA,
      customNamespaces: {
        [WEBRTC_NAMESPACE]: cast.framework.system.MessageType.JSON
      }
    });

    log('Waiting for connection...');
  </script>
</body>
</html>
