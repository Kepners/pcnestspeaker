<!DOCTYPE html>
<html>
<head>
  <title>PC Nest Speaker - WebRTC Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <style>
    body { background: #334E58; margin: 0; padding: 0; }
    #status { color: #FCBFB7; font-family: sans-serif; font-size: 24px; text-align: center; padding-top: 40%; }
  </style>
</head>
<body>
  <cast-media-player></cast-media-player>
  <div id="status">PC Nest Speaker</div>
  <audio id="webrtc-audio" autoplay></audio>

  <script>
    const WEBRTC_NAMESPACE = 'urn:x-cast:com.pcnestspeaker.webrtc';

    // Cast framework setup
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const playbackConfig = new cast.framework.PlaybackConfig();

    // Low latency settings for HTTP fallback
    playbackConfig.autoResumeDuration = 0;
    playbackConfig.autoPauseDuration = 0;
    playbackConfig.initialBandwidth = 100000000;
    playbackConfig.disablePreload = true;
    playbackConfig.autoResumeNumberOfSegments = 0;
    playbackConfig.shakaConfig = {
      streaming: {
        bufferingGoal: 0.1,
        rebufferingGoal: 0,
        bufferBehind: 0,
        lowLatencyMode: true,
        segmentPrefetchLimit: 0,
        retryParameters: { maxAttempts: 1, timeout: 1000 }
      }
    };

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (request) => {
        if (request.media) {
          request.media.streamType = cast.framework.messages.StreamType.LIVE;
          request.autoplay = true;
          request.currentTime = 0;
        }
        return request;
      }
    );

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.PRELOAD,
      () => null
    );

    playerManager.setPlaybackConfig(playbackConfig);

    // ===================
    // WebRTC SUPPORT
    // ===================
    let peerConnection = null;
    const audioElement = document.getElementById('webrtc-audio');

    function log(msg) {
      console.log('[WebRTC] ' + msg);
      document.getElementById('status').textContent = msg;
    }

    function createPeerConnection() {
      const config = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      };

      peerConnection = new RTCPeerConnection(config);
      log('PeerConnection created');

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          log('Sending ICE candidate');
          sendMessage({ type: 'ice', candidate: event.candidate });
        }
      };

      peerConnection.ontrack = (event) => {
        log('Received audio track!');
        if (event.streams && event.streams[0]) {
          audioElement.srcObject = event.streams[0];
          audioElement.play().catch(e => log('Play error: ' + e));
          log('Playing WebRTC audio');
        }
      };

      peerConnection.onconnectionstatechange = () => {
        log('Connection: ' + peerConnection.connectionState);
      };

      return peerConnection;
    }

    function sendMessage(data) {
      context.sendCustomMessage(WEBRTC_NAMESPACE, undefined, data);
    }

    async function handleOffer(offer) {
      log('Received SDP offer');

      if (!peerConnection) {
        createPeerConnection();
      }

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        log('Set remote description');

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        log('Created answer');

        sendMessage({ type: 'answer', sdp: answer });
        log('Sent SDP answer');
      } catch (e) {
        log('Offer error: ' + e.message);
      }
    }

    async function handleIce(candidate) {
      if (peerConnection && candidate) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
          log('Added ICE candidate');
        } catch (e) {
          log('ICE error: ' + e.message);
        }
      }
    }

    function handleMessage(event) {
      log('Message received: ' + event.data.type);
      const data = event.data;

      switch (data.type) {
        case 'offer':
          handleOffer(data.sdp);
          break;
        case 'ice':
          handleIce(data.candidate);
          break;
        case 'close':
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
            log('Connection closed');
          }
          break;
        default:
          log('Unknown message type: ' + data.type);
      }
    }

    // Register custom message handler for WebRTC signaling
    context.addCustomMessageListener(WEBRTC_NAMESPACE, handleMessage);

    // Start receiver
    context.start({
      playbackConfig: playbackConfig,
      skipPlayersLoad: false,
      disableIdleTimeout: true,
      supportedCommands: cast.framework.messages.Command.ALL_BASIC_MEDIA,
      customNamespaces: {
        [WEBRTC_NAMESPACE]: cast.framework.system.MessageType.JSON
      }
    });

    log('WebRTC receiver ready');
  </script>
</body>
</html>
