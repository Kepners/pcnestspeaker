<!DOCTYPE html>
<html>
<head>
  <title>PC Nest Speaker - Audio Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #334E58; overflow: hidden; }
    #status {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FCBFB7;
      font-family: 'Segoe UI', sans-serif;
      font-size: 24px;
      text-align: center;
    }
    #player { display: none; }
  </style>
</head>
<body>
  <cast-media-player id="player"></cast-media-player>
  <div id="status">Waiting for connection...</div>

  <!-- Audio elements (invisible) -->
  <audio id="webrtc-audio" autoplay></audio>
  <audio id="hls-audio" autoplay></audio>

  <script>
    const WEBRTC_NAMESPACE = 'urn:x-cast:com.pcnestspeaker.webrtc';

    // ===================
    // Cast Framework Setup
    // ===================
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const playbackConfig = new cast.framework.PlaybackConfig();

    // Low latency settings
    playbackConfig.autoResumeDuration = 0;
    playbackConfig.autoPauseDuration = 0;
    playbackConfig.initialBandwidth = 100000000;
    playbackConfig.disablePreload = true;

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.PRELOAD,
      () => null
    );

    playerManager.setPlaybackConfig(playbackConfig);

    // ===================
    // WebRTC via MediaMTX WHEP
    // ===================
    let peerConnection = null;
    let whepResourceUrl = null;
    const webrtcAudio = document.getElementById('webrtc-audio');
    const hlsAudio = document.getElementById('hls-audio');
    let hlsPlayer = null;
    let currentMode = null; // 'webrtc' or 'hls'

    function log(msg) {
      console.log('[Audio] ' + msg);
      document.getElementById('status').textContent = msg;
    }

    // Retry configuration
    let retryCount = 0;
    const MAX_RETRIES = 5;
    const RETRY_DELAY = 2000;

    async function connectWebRTC(serverUrl, streamName = 'pcaudio') {
      log('Connecting WebRTC...');
      currentMode = 'webrtc';

      // Stop any HLS playback
      if (hlsPlayer) {
        hlsPlayer.destroy();
        hlsPlayer = null;
      }
      hlsAudio.pause();
      hlsAudio.src = '';

      const iceConfig = { iceServers: [], iceTransportPolicy: 'all' };
      peerConnection = new RTCPeerConnection(iceConfig);

      peerConnection.ontrack = (event) => {
        console.log('[WebRTC] Track received:', event.track.kind);
        if (event.track.kind === 'audio') {
          if (event.streams && event.streams[0]) {
            webrtcAudio.srcObject = event.streams[0];
          } else {
            webrtcAudio.srcObject = new MediaStream([event.track]);
          }
          webrtcAudio.muted = false;
          webrtcAudio.volume = 1.0;
          webrtcAudio.play().then(() => {
            log('Streaming audio...');
          }).catch(e => {
            webrtcAudio.muted = true;
            webrtcAudio.play().then(() => {
              setTimeout(() => { webrtcAudio.muted = false; }, 100);
              log('Streaming audio...');
            });
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log('[WebRTC] Connection state:', state);
        if (state === 'connected') log('Streaming audio...');
        else if (state === 'failed') {
          log('Reconnecting...');
          setTimeout(() => { disconnect(); connectWebRTC(serverUrl, streamName); }, 3000);
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('[WebRTC] ICE state:', peerConnection.iceConnectionState);
      };

      peerConnection.addTransceiver('audio', { direction: 'recvonly' });

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      // Wait for ICE gathering
      await new Promise((resolve) => {
        if (peerConnection.iceGatheringState === 'complete') resolve();
        else {
          const check = () => {
            if (peerConnection.iceGatheringState === 'complete') {
              peerConnection.removeEventListener('icegatheringstatechange', check);
              resolve();
            }
          };
          peerConnection.addEventListener('icegatheringstatechange', check);
          setTimeout(resolve, 2000);
        }
      });

      const whepUrl = serverUrl + '/' + streamName + '/whep';
      console.log('[WebRTC] WHEP URL:', whepUrl);

      try {
        const response = await fetch(whepUrl, {
          method: 'POST',
          mode: 'cors',
          headers: { 'Content-Type': 'application/sdp' },
          body: peerConnection.localDescription.sdp
        });

        if (!response.ok) throw new Error('WHEP error ' + response.status);

        const location = response.headers.get('Location');
        if (location) {
          whepResourceUrl = location.startsWith('/') ? serverUrl + location : location;
        }

        const answerSdp = await response.text();
        await peerConnection.setRemoteDescription({ type: 'answer', sdp: answerSdp });
        retryCount = 0;
        console.log('[WebRTC] Connected successfully');

      } catch (e) {
        console.error('[WebRTC] Error:', e);
        retryCount++;
        if (retryCount <= MAX_RETRIES) {
          log(`Retry ${retryCount}/${MAX_RETRIES}...`);
          if (peerConnection) { peerConnection.close(); peerConnection = null; }
          setTimeout(() => connectWebRTC(serverUrl, streamName), RETRY_DELAY);
        } else {
          log('Connection failed');
          retryCount = 0;
        }
      }
    }

    function connectHLS(hlsUrl) {
      log('Connecting HLS...');
      currentMode = 'hls';

      // Stop any WebRTC
      disconnect();

      if (Hls.isSupported()) {
        hlsPlayer = new Hls({
          enableWorker: true,
          lowLatencyMode: true,
          liveSyncDurationCount: 1,
          liveMaxLatencyDurationCount: 3,
          liveDurationInfinity: true,
          highBufferWatchdogPeriod: 1
        });

        hlsPlayer.loadSource(hlsUrl);
        hlsPlayer.attachMedia(hlsAudio);

        hlsPlayer.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('[HLS] Manifest parsed, playing...');
          hlsAudio.play().then(() => {
            log('Streaming audio...');
          }).catch(e => console.error('[HLS] Play error:', e));
        });

        hlsPlayer.on(Hls.Events.ERROR, (event, data) => {
          console.error('[HLS] Error:', data.type, data.details);
          if (data.fatal) {
            log('HLS error - retrying...');
            hlsPlayer.destroy();
            setTimeout(() => connectHLS(hlsUrl), 3000);
          }
        });
      } else if (hlsAudio.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        hlsAudio.src = hlsUrl;
        hlsAudio.play().then(() => log('Streaming audio...')).catch(e => log('Play error'));
      } else {
        log('HLS not supported');
      }
    }

    function disconnect() {
      if (peerConnection) {
        if (whepResourceUrl) {
          fetch(whepResourceUrl, { method: 'DELETE' }).catch(() => {});
          whepResourceUrl = null;
        }
        peerConnection.close();
        peerConnection = null;
        webrtcAudio.srcObject = null;
      }
      if (hlsPlayer) {
        hlsPlayer.destroy();
        hlsPlayer = null;
      }
      hlsAudio.pause();
      hlsAudio.src = '';
      currentMode = null;
    }

    // Handle custom messages
    function handleMessage(event) {
      console.log('[Cast] Message:', event.data);
      const data = event.data;

      switch (data.type) {
        case 'connect':
          if (data.url) connectWebRTC(data.url, data.stream || 'pcaudio');
          break;
        case 'hls':
          if (data.url) connectHLS(data.url);
          break;
        case 'disconnect':
        case 'close':
          disconnect();
          log('Disconnected');
          break;
      }
    }

    context.addCustomMessageListener(WEBRTC_NAMESPACE, handleMessage);

    // Intercept LOAD requests
    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (request) => {
        console.log('[Cast] LOAD request:', JSON.stringify(request, null, 2));

        if (request.media && request.media.contentId) {
          const contentId = request.media.contentId;

          // Handle webrtc:// prefix
          if (contentId.startsWith('webrtc://')) {
            const httpsUrl = contentId.replace('webrtc://', '');
            const streamName = (request.media.customData && request.media.customData.stream) || 'pcaudio';
            console.log('[Cast] WebRTC URL:', httpsUrl);
            connectWebRTC(httpsUrl, streamName);
            return null;
          }

          // Handle HLS URLs (.m3u8)
          if (contentId.includes('.m3u8')) {
            console.log('[Cast] HLS URL:', contentId);
            connectHLS(contentId);
            return null;
          }
        }

        // Check customData for WebRTC
        if (request.media && request.media.customData && request.media.customData.webrtcUrl) {
          connectWebRTC(request.media.customData.webrtcUrl, request.media.customData.stream || 'pcaudio');
          return null;
        }

        if (request.customData && request.customData.webrtcUrl) {
          connectWebRTC(request.customData.webrtcUrl, request.customData.stream || 'pcaudio');
          return null;
        }

        // Default: let Cast framework handle it
        if (request.media) {
          request.media.streamType = cast.framework.messages.StreamType.LIVE;
          request.autoplay = true;
        }
        return request;
      }
    );

    context.start({
      playbackConfig: playbackConfig,
      skipPlayersLoad: false,
      disableIdleTimeout: true,
      supportedCommands: cast.framework.messages.Command.ALL_BASIC_MEDIA,
      customNamespaces: {
        [WEBRTC_NAMESPACE]: cast.framework.system.MessageType.JSON
      }
    });

    log('Waiting for connection...');
  </script>
</body>
</html>
