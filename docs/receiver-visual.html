<!DOCTYPE html>
<html>
<head>
  <title>PC Nest Speaker - WebRTC Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0a; overflow: hidden; }

    /* ========================================
       SPLASH SCREEN - PC NEST SPEAKER BRANDING
       ======================================== */
    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #334E58 0%, #1a2a30 50%, #33261D 100%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    /* Logo animation */
    #splash-logo {
      width: 200px;
      height: 200px;
      border-radius: 30px;
      animation: pulse 2s ease-in-out infinite;
      box-shadow: 0 10px 60px rgba(0,0,0,0.4);
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.9; }
      50% { transform: scale(1.05); opacity: 1; }
    }

    /* Splash video - your branded animation */
    #splash-video {
      max-width: 50%;
      max-height: 50%;
      object-fit: contain;
      border-radius: 20px;
    }

    #splash-title {
      color: #FCBFB7;
      font-family: 'Segoe UI', sans-serif;
      font-size: 64px;
      font-weight: 300;
      letter-spacing: 12px;
      margin-top: 40px;
      text-shadow: 0 4px 30px rgba(252, 191, 183, 0.4);
      animation: fadeIn 1s ease-out;
    }
    #splash-subtitle {
      color: rgba(255,255,255,0.7);
      font-family: 'Segoe UI', sans-serif;
      font-size: 22px;
      font-weight: 300;
      letter-spacing: 6px;
      margin-top: 15px;
      animation: fadeIn 1.5s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ========================================
       GEORGE LUCAS WIPE TRANSITION
       Classic Star Wars horizontal wipe effect
       ======================================== */
    #wipe-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #334E58 0%, #1a2a30 50%, #33261D 100%);
      z-index: 99;
      transform: translateX(0);
      pointer-events: none;
    }
    #wipe-overlay.wipe-out {
      animation: wipeLeft 1.2s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    @keyframes wipeLeft {
      0% { transform: translateX(0); }
      100% { transform: translateX(-100%); }
    }

    /* Alternative: Iris wipe (circle reveal) - Star Wars style */
    #iris-wipe {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #0a0a0a;
      z-index: 98;
      clip-path: circle(0% at 50% 50%);
      pointer-events: none;
    }
    #iris-wipe.reveal {
      animation: irisReveal 1.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    @keyframes irisReveal {
      0% { clip-path: circle(0% at 50% 50%); }
      100% { clip-path: circle(150% at 50% 50%); }
    }

    /* Splash hidden state */
    #splash-screen.hidden {
      display: none;
    }

    /* Ambient PHOTO background - fullscreen, behind everything */
    /* Two images for crossfade effect */
    .ambient-photo {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 1;
      opacity: 0;
      transition: opacity 2s ease-in-out;
    }
    .ambient-photo.visible { opacity: 1; }

    /* Gradient overlay for text readability */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(
        to bottom,
        rgba(51, 78, 88, 0.3) 0%,
        rgba(51, 78, 88, 0.1) 50%,
        rgba(51, 78, 88, 0.5) 100%
      );
      z-index: 2;
      pointer-events: none;
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }
    #overlay.visible { opacity: 1; }

    /* Status text */
    #status {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
      font-family: 'Segoe UI', sans-serif;
      font-size: 28px;
      font-weight: 300;
      text-align: center;
      z-index: 10;
      padding: 12px 30px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50px;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 20px rgba(0,0,0,0.1);
      transition: all 0.5s ease;
    }
    #status.streaming {
      color: #FCBFB7;
      background: rgba(51, 78, 88, 0.8);
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    /* App branding - next to logo */
    #branding {
      position: fixed;
      top: 50px;
      left: 115px;
      color: #334E58;
      font-family: 'Segoe UI', sans-serif;
      font-size: 22px;
      font-weight: 600;
      letter-spacing: 3px;
      z-index: 10;
      transition: color 1s ease;
    }
    #branding.streaming {
      color: rgba(252, 191, 183, 0.9);
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    /* App logo in corner */
    #logo {
      position: fixed;
      top: 30px;
      left: 40px;
      width: 60px;
      height: 60px;
      z-index: 10;
    }

    /* Cast media player - hidden for WebRTC, shown for HLS */
    #player {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;  /* Behind ambient video */
    }
    #player.active {
      display: block;
    }
    /* For HLS mode, hide the video element from cast-media-player */
    #player.audio-only ::part(video) {
      display: none;
    }
  </style>
</head>
<body>
  <cast-media-player id="player"></cast-media-player>

  <!-- George Lucas wipe transition overlay -->
  <div id="wipe-overlay"></div>

  <!-- Splash screen - PC NEST SPEAKER BRANDING (5 seconds) -->
  <div id="splash-screen">
    <!-- App logo (PNG) -->
    <img id="splash-logo" src="https://kepners.github.io/pcnestspeaker/logo.png" alt="PC Nest Speaker" />
    <!-- Your branded splash video (backup) -->
    <video id="splash-video" autoplay loop muted playsinline style="display:none;">
      <source src="https://kepners.github.io/pcnestspeaker/splash.mp4" type="video/mp4">
    </video>
    <div id="splash-title">PC NEST SPEAKER</div>
    <div id="splash-subtitle">STREAMING YOUR WORLD</div>
  </div>

  <!-- Ambient PHOTO slideshow background (two images for crossfade) -->
  <img id="ambient-photo-1" class="ambient-photo" src="" alt="">
  <img id="ambient-photo-2" class="ambient-photo" src="" alt="">
  <div id="overlay"></div>

  <!-- UI elements -->
  <!-- Logo in corner - using inline SVG for reliability -->
  <svg id="logo" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:#FCBFB7"/>
        <stop offset="100%" style="stop-color:#A69888"/>
      </linearGradient>
    </defs>
    <!-- Speaker icon -->
    <rect x="15" y="30" width="25" height="40" rx="4" fill="url(#logoGrad)"/>
    <path d="M40 30 L60 15 L60 85 L40 70 Z" fill="url(#logoGrad)"/>
    <!-- Sound waves -->
    <path d="M68 35 Q80 50 68 65" stroke="#FCBFB7" stroke-width="4" fill="none" opacity="0.8"/>
    <path d="M76 25 Q95 50 76 75" stroke="#FCBFB7" stroke-width="4" fill="none" opacity="0.5"/>
  </svg>
  <div id="branding">PC NEST SPEAKER</div>
  <div id="status">Waiting for connection...</div>

  <!-- WebRTC audio element (invisible) -->
  <audio id="webrtc-audio" autoplay></audio>

  <script>
    const WEBRTC_NAMESPACE = 'urn:x-cast:com.pcnestspeaker.webrtc';

    // ===================
    // SPLASH & TRANSITION TIMING
    // ===================
    const SPLASH_DURATION = 5000;  // 5 seconds branded splash
    const WIPE_DURATION = 1200;    // George Lucas wipe transition
    let splashComplete = false;

    // ===================
    // Ambient PHOTO Slideshow System - Unsplash (CORS-enabled, works on Cast)
    // Much lighter than 4K videos, works reliably on Shield/TVs
    // ===================
    const ambientPhotos = [
      // Ocean & Water
      'https://images.unsplash.com/photo-1505118380757-91f5f5632de0?w=1920&q=80',
      'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=1920&q=80',
      'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=1920&q=80',
      'https://images.unsplash.com/photo-1439405326854-014607f694d7?w=1920&q=80',
      // Mountains
      'https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?w=1920&q=80',
      'https://images.unsplash.com/photo-1519681393784-d120267933ba?w=1920&q=80',
      'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1920&q=80',
      'https://images.unsplash.com/photo-1454496522488-7a8e488e8606?w=1920&q=80',
      // Forest & Nature
      'https://images.unsplash.com/photo-1448375240586-882707db888b?w=1920&q=80',
      'https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=1920&q=80',
      'https://images.unsplash.com/photo-1476231682828-37e571bc172f?w=1920&q=80',
      'https://images.unsplash.com/photo-1502082553048-f009c37129b9?w=1920&q=80',
      // Sky & Clouds
      'https://images.unsplash.com/photo-1534088568595-a066f410bcda?w=1920&q=80',
      'https://images.unsplash.com/photo-1517483000871-1dbf64a6e1c6?w=1920&q=80',
      'https://images.unsplash.com/photo-1504608524841-42fe6f032b4b?w=1920&q=80',
      'https://images.unsplash.com/photo-1513002749550-c59d786b8e6c?w=1920&q=80',
      // Desert & Canyon
      'https://images.unsplash.com/photo-1509316785289-025f5b846b35?w=1920&q=80',
      'https://images.unsplash.com/photo-1474044159687-1ee9f3a51722?w=1920&q=80',
      'https://images.unsplash.com/photo-1469854523086-cc02fe5d8800?w=1920&q=80',
      // Night Sky & Stars
      'https://images.unsplash.com/photo-1419242902214-272b3f66ee7a?w=1920&q=80',
      'https://images.unsplash.com/photo-1507400492013-162706c8c05e?w=1920&q=80',
      'https://images.unsplash.com/photo-1465101162946-4377e57745c3?w=1920&q=80',
      // Aurora
      'https://images.unsplash.com/photo-1483347756197-71ef80e95f73?w=1920&q=80',
      'https://images.unsplash.com/photo-1531366936337-7c912a4589a7?w=1920&q=80',
      // Waterfall
      'https://images.unsplash.com/photo-1432405972618-c60b0225b8f9?w=1920&q=80',
      'https://images.unsplash.com/photo-1546182990-dffeafbe841d?w=1920&q=80',
      // Lake & Reflection
      'https://images.unsplash.com/photo-1439066615861-d1af74d74000?w=1920&q=80',
      'https://images.unsplash.com/photo-1501785888041-af3ef285b470?w=1920&q=80',
      // Fields & Meadows
      'https://images.unsplash.com/photo-1500534623283-c6c3c930c8f6?w=1920&q=80',
      'https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05?w=1920&q=80',
      // Space (abstract/nebula)
      'https://images.unsplash.com/photo-1462331940025-496dfbfc7564?w=1920&q=80',
      'https://images.unsplash.com/photo-1444703686981-a3abbc4d4fe3?w=1920&q=80',
    ];

    // Slideshow state
    let currentPhotoIndex = 0;
    let activePhotoElement = 1;  // Which img element is currently visible (1 or 2)
    let slideshowInterval = null;
    let slideshowStarted = false;
    const SLIDESHOW_INTERVAL = 10000;  // 10 seconds per photo

    const photo1 = document.getElementById('ambient-photo-1');
    const photo2 = document.getElementById('ambient-photo-2');

    // Preload next photo for smooth transition
    function preloadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(url);
        img.onerror = () => reject(url);
        img.src = url;
      });
    }

    // Get next random photo (different from current)
    function getNextPhotoIndex() {
      let next;
      do {
        next = Math.floor(Math.random() * ambientPhotos.length);
      } while (next === currentPhotoIndex && ambientPhotos.length > 1);
      return next;
    }

    // Crossfade to next photo
    async function showNextPhoto() {
      const nextIndex = getNextPhotoIndex();
      const nextUrl = ambientPhotos[nextIndex];
      console.log('[Ambient] Loading photo:', nextUrl);

      try {
        await preloadImage(nextUrl);
        currentPhotoIndex = nextIndex;

        // Crossfade: show on inactive element, hide active element
        if (activePhotoElement === 1) {
          photo2.src = nextUrl;
          photo2.classList.add('visible');
          photo1.classList.remove('visible');
          activePhotoElement = 2;
        } else {
          photo1.src = nextUrl;
          photo1.classList.add('visible');
          photo2.classList.remove('visible');
          activePhotoElement = 1;
        }
        console.log('[Ambient] Photo displayed');
      } catch (e) {
        console.log('[Ambient] Photo load error, trying next...');
        // Try another photo immediately
        setTimeout(showNextPhoto, 100);
      }
    }

    // Start the photo slideshow
    function startAmbientVideos() {  // Keep function name for compatibility
      if (slideshowStarted) return;
      slideshowStarted = true;

      console.log('[Ambient] Starting photo slideshow (' + ambientPhotos.length + ' photos, ' + (SLIDESHOW_INTERVAL/1000) + 's each)');

      // Show first photo immediately
      currentPhotoIndex = Math.floor(Math.random() * ambientPhotos.length);
      const firstUrl = ambientPhotos[currentPhotoIndex];
      console.log('[Ambient] First photo:', firstUrl);

      photo1.src = firstUrl;
      // Note: Don't add 'visible' class here - finishTransition() will do it after wipe

      // Start slideshow interval
      slideshowInterval = setInterval(showNextPhoto, SLIDESHOW_INTERVAL);
    }

    // Stop slideshow (for cleanup)
    function stopAmbientSlideshow() {
      if (slideshowInterval) {
        clearInterval(slideshowInterval);
        slideshowInterval = null;
      }
      slideshowStarted = false;
    }

    // ===================
    // Cast Framework Setup
    // ===================
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const playbackConfig = new cast.framework.PlaybackConfig();

    // Low latency settings for HTTP fallback
    playbackConfig.autoResumeDuration = 0;
    playbackConfig.autoPauseDuration = 0;
    playbackConfig.initialBandwidth = 100000000;
    playbackConfig.disablePreload = true;
    playbackConfig.autoResumeNumberOfSegments = 0;
    playbackConfig.shakaConfig = {
      streaming: {
        bufferingGoal: 0.1,
        rebufferingGoal: 0,
        bufferBehind: 0,
        lowLatencyMode: true,
        segmentPrefetchLimit: 0,
        retryParameters: { maxAttempts: 1, timeout: 1000 }
      }
    };

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.PRELOAD,
      () => null
    );

    playerManager.setPlaybackConfig(playbackConfig);

    // Add player state listeners for HLS debugging
    playerManager.addEventListener(cast.framework.events.EventType.PLAYER_LOADING, () => {
      console.log('[Cast Player] LOADING');
      log('Loading stream...');
    });
    playerManager.addEventListener(cast.framework.events.EventType.PLAYER_LOAD_COMPLETE, () => {
      console.log('[Cast Player] LOAD COMPLETE');
      log('Stream loaded!');
    });
    playerManager.addEventListener(cast.framework.events.EventType.PLAYING, () => {
      console.log('[Cast Player] PLAYING');
      log('Streaming audio...');
      transitionToStreaming();
    });
    playerManager.addEventListener(cast.framework.events.EventType.BUFFERING, () => {
      console.log('[Cast Player] BUFFERING');
      log('Buffering...');
    });
    playerManager.addEventListener(cast.framework.events.EventType.ERROR, (event) => {
      console.error('[Cast Player] ERROR:', event.detailedErrorCode, event.error);
      log('Error: ' + (event.error || event.detailedErrorCode));
    });
    playerManager.addEventListener(cast.framework.events.EventType.MEDIA_STATUS, (event) => {
      console.log('[Cast Player] MEDIA_STATUS:', event.mediaStatus?.playerState);
    });

    // ===================
    // WebRTC via MediaMTX WHEP
    // ===================
    let peerConnection = null;
    let whepResourceUrl = null;
    const audioElement = document.getElementById('webrtc-audio');

    function log(msg) {
      console.log('[WebRTC] ' + msg);
      document.getElementById('status').textContent = msg;
    }

    function hideDefaultPlayer() {
      const player = document.getElementById('player');
      if (player) {
        player.classList.remove('active');
        player.classList.remove('audio-only');
      }
    }

    function showDefaultPlayer(audioOnly = true) {
      const player = document.getElementById('player');
      if (player) {
        player.classList.add('active');
        if (audioOnly) player.classList.add('audio-only');
      }
    }

    // Check if URL is HLS format
    function isHlsUrl(url) {
      if (!url) return false;
      return url.toLowerCase().includes('.m3u8') ||
             url.toLowerCase().includes('mpegurl');
    }

    // ===================
    // GEORGE LUCAS WIPE TRANSITION
    // Shows splash for 5 seconds, then wipes to ambient videos
    // ===================
    let hasTransitioned = false;

    function startSplashSequence() {
      console.log('[UI] Starting PC Nest Speaker splash sequence (5 seconds)...');

      // After SPLASH_DURATION, do the George Lucas wipe
      setTimeout(() => {
        doGeorgeLucasWipe();
      }, SPLASH_DURATION);
    }

    function doGeorgeLucasWipe() {
      console.log('[UI] Starting George Lucas wipe transition...');

      const splash = document.getElementById('splash-screen');
      const wipeOverlay = document.getElementById('wipe-overlay');

      // 1. Trigger the wipe animation (slides left, revealing content behind)
      if (wipeOverlay) {
        wipeOverlay.classList.add('wipe-out');
      }

      // 2. Hide splash screen as wipe starts
      setTimeout(() => {
        if (splash) splash.classList.add('hidden');
      }, 100);

      // 3. After wipe completes, remove the overlay
      setTimeout(() => {
        if (wipeOverlay) wipeOverlay.style.display = 'none';
        finishTransition();
      }, WIPE_DURATION);
    }

    function finishTransition() {
      if (hasTransitioned) return;
      hasTransitioned = true;

      console.log('[UI] Transition complete - showing ambient photos');

      // NOW make ambient photo visible (wipe is complete)
      // Show whichever photo element is active (photo1 has first image)
      if (photo1 && photo1.src) photo1.classList.add('visible');

      // Show overlay for ambient videos
      const overlay = document.getElementById('overlay');
      if (overlay) overlay.classList.add('visible');

      // Update UI elements for streaming mode
      const status = document.getElementById('status');
      const branding = document.getElementById('branding');
      if (status) status.classList.add('streaming');
      if (branding) branding.classList.add('streaming');
    }

    function transitionToStreaming() {
      // If splash sequence hasn't started, start it now
      if (!splashComplete) {
        splashComplete = true;
        startSplashSequence();
      }
    }

    // Retry configuration
    let retryCount = 0;
    const MAX_RETRIES = 5;
    const RETRY_DELAY = 2000; // 2 seconds

    async function connectToMediaMTX(serverUrl, streamName = 'pcaudio', forceRelay = false) {
      log(forceRelay ? 'Connecting (relay)...' : 'Connecting...');

      // Start ambient videos when connecting (only first time)
      if (!forceRelay) startAmbientVideos();

      // ICE configuration - empty for local network (no STUN needed on same LAN)
      // This dramatically speeds up ICE gathering
      const iceConfig = {
        iceServers: [],
        iceTransportPolicy: 'all'
      };

      console.log('[WebRTC] ICE transport policy:', iceConfig.iceTransportPolicy);

      peerConnection = new RTCPeerConnection(iceConfig);

      peerConnection.ontrack = (event) => {
        console.log('[WebRTC] Track received:', event.track.kind, event.track.readyState, event.track.muted);
        log('Track received!');

        if (event.track.kind === 'audio') {
          if (event.streams && event.streams[0]) {
            audioElement.srcObject = event.streams[0];

            audioElement.muted = false;
            audioElement.volume = 1.0;

            audioElement.play().then(() => {
              log('Streaming audio...');
              transitionToStreaming();
            }).catch(e => {
              audioElement.muted = true;
              audioElement.play().then(() => {
                setTimeout(() => {
                  audioElement.muted = false;
                  log('Streaming audio...');
                  transitionToStreaming();
                }, 100);
              }).catch(e2 => log('Play failed'));
            });
          } else {
            const stream = new MediaStream([event.track]);
            audioElement.srcObject = stream;
            audioElement.play().catch(e => log('Play error'));
          }
        }
      };

      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log('[WebRTC] Connection state:', state);
        if (state === 'connected') {
          log('Streaming audio...');
          transitionToStreaming();
        } else if (state === 'failed') {
          log('Reconnecting...');
          setTimeout(() => {
            disconnect();
            connectToMediaMTX(serverUrl, streamName);
          }, 3000);
        }
      };

      // Track if we've tried relay mode
      let triedRelayMode = !forceRelay; // If already in relay mode, don't retry

      // ICE state debugging
      peerConnection.oniceconnectionstatechange = () => {
        console.log('[WebRTC] ICE state:', peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'failed') {
          if (!triedRelayMode) {
            log('ICE failed - trying relay mode...');
            console.log('[WebRTC] Retrying with TURN relay only');
            triedRelayMode = true;
            disconnect();
            // Retry with forced relay
            connectToMediaMTX(serverUrl, streamName, true);
          } else {
            log('ICE failed');
          }
        } else if (peerConnection.iceConnectionState === 'disconnected') {
          log('ICE disconnected');
        } else if (peerConnection.iceConnectionState === 'checking') {
          log('ICE checking...');
        } else if (peerConnection.iceConnectionState === 'connected') {
          log('ICE connected!');
        }
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log('[WebRTC] ICE gathering state:', peerConnection.iceGatheringState);
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('[WebRTC] Local ICE candidate:', event.candidate.type, event.candidate.address);
        } else {
          console.log('[WebRTC] ICE gathering complete');
        }
      };

      peerConnection.addTransceiver('audio', { direction: 'recvonly' });

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      await new Promise((resolve) => {
        if (peerConnection.iceGatheringState === 'complete') {
          resolve();
        } else {
          const checkState = () => {
            if (peerConnection.iceGatheringState === 'complete') {
              peerConnection.removeEventListener('icegatheringstatechange', checkState);
              resolve();
            }
          };
          peerConnection.addEventListener('icegatheringstatechange', checkState);
          setTimeout(resolve, 2000);
        }
      });

      const whepUrl = serverUrl + '/' + streamName + '/whep';
      console.log('[WebRTC] WHEP URL:', whepUrl);

      try {
        const response = await fetch(whepUrl, {
          method: 'POST',
          mode: 'cors',
          headers: { 'Content-Type': 'application/sdp' },
          body: peerConnection.localDescription.sdp
        });

        if (!response.ok) {
          throw new Error('WHEP error ' + response.status);
        }

        const location = response.headers.get('Location');
        if (location) {
          whepResourceUrl = location.startsWith('/') ? serverUrl + location : location;
        }

        const answerSdp = await response.text();
        console.log('[WebRTC] SDP Answer received:', answerSdp.substring(0, 500) + '...');

        // Log ICE candidates from answer
        const iceCandidates = answerSdp.match(/a=candidate:.*/g) || [];
        console.log('[WebRTC] Remote ICE candidates:', iceCandidates.length);
        iceCandidates.forEach(c => console.log('[WebRTC]   ', c));

        await peerConnection.setRemoteDescription({ type: 'answer', sdp: answerSdp });

        // Success - reset retry count
        retryCount = 0;
        console.log('[WebRTC] WHEP connection successful, SDP answer processed');

      } catch (e) {
        console.error('[WebRTC] Error:', e);

        // Retry logic - WHEP might fail if stream not ready yet
        retryCount++;
        if (retryCount <= MAX_RETRIES) {
          log(`Retry ${retryCount}/${MAX_RETRIES}...`);
          console.log(`[WebRTC] Retrying in ${RETRY_DELAY}ms (attempt ${retryCount}/${MAX_RETRIES})`);

          // Clean up failed connection
          if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
          }

          // Wait and retry
          setTimeout(() => {
            connectToMediaMTX(serverUrl, streamName);
          }, RETRY_DELAY);
        } else {
          log('Connection failed');
          console.error('[WebRTC] Max retries exceeded');
          retryCount = 0; // Reset for next connection attempt
        }
      }
    }

    function disconnect() {
      if (peerConnection) {
        if (whepResourceUrl) {
          fetch(whepResourceUrl, { method: 'DELETE' }).catch(() => {});
          whepResourceUrl = null;
        }
        peerConnection.close();
        peerConnection = null;
        audioElement.srcObject = null;
        log('Disconnected');
      }
    }

    function handleMessage(event) {
      console.log('[Cast] Message:', event.data);
      const data = event.data;

      switch (data.type) {
        case 'connect':
          if (data.url) {
            connectToMediaMTX(data.url, data.stream || 'pcaudio');
          }
          break;
        case 'disconnect':
        case 'close':
          disconnect();
          break;
      }
    }

    context.addCustomMessageListener(WEBRTC_NAMESPACE, handleMessage);

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (request) => {
        console.log('[Cast] LOAD request:', JSON.stringify(request, null, 2));

        if (request.media && request.media.contentId) {
          const contentId = request.media.contentId;

          // Handle webrtc:// prefix (used for Cast Groups)
          if (contentId.startsWith('webrtc://')) {
            const httpsUrl = contentId.replace('webrtc://', '');
            // Get stream name from customData if available
            const streamName = (request.media.customData && request.media.customData.stream) || 'pcaudio';
            console.log('[Cast] GROUP mode - webrtc:// URL:', httpsUrl, 'stream:', streamName);
            hideDefaultPlayer();
            connectToMediaMTX(httpsUrl, streamName);
            return null;
          }

          // *** HLS MODE FOR TVs/SHIELD ***
          // If URL is HLS (.m3u8), use built-in Cast player with ambient visuals
          if (isHlsUrl(contentId)) {
            console.log('[Cast] HLS mode - using built-in player with ambient visuals');
            console.log('[Cast] HLS URL:', contentId);

            // Show cast-media-player (audio-only mode hides video, shows ambient instead)
            showDefaultPlayer(true);

            // Start ambient videos
            startAmbientVideos();

            // Transition UI
            setTimeout(() => {
              transitionToStreaming();
              log('Streaming audio...');
            }, 1000);

            // Let the LOAD flow through to Cast player
            if (request.media) {
              request.media.streamType = cast.framework.messages.StreamType.LIVE;
              request.autoplay = true;
              request.currentTime = 0;
            }
            return request;
          }
        }

        if (request.media && request.media.customData && request.media.customData.webrtcUrl) {
          hideDefaultPlayer();
          connectToMediaMTX(request.media.customData.webrtcUrl, request.media.customData.stream || 'pcaudio');
          return null;
        }

        if (request.customData && request.customData.webrtcUrl) {
          hideDefaultPlayer();
          connectToMediaMTX(request.customData.webrtcUrl, request.customData.stream || 'pcaudio');
          return null;
        }

        // Default: assume HLS or other media format
        console.log('[Cast] Default LOAD - passing to Cast player');
        if (request.media) {
          request.media.streamType = cast.framework.messages.StreamType.LIVE;
          request.autoplay = true;
          request.currentTime = 0;
        }

        // Start ambient videos for any media
        startAmbientVideos();
        setTimeout(() => {
          transitionToStreaming();
          log('Streaming audio...');
        }, 1000);

        return request;
      }
    );

    context.start({
      playbackConfig: playbackConfig,
      skipPlayersLoad: false,
      disableIdleTimeout: true,
      supportedCommands: cast.framework.messages.Command.ALL_BASIC_MEDIA,
      customNamespaces: {
        [WEBRTC_NAMESPACE]: cast.framework.system.MessageType.JSON
      }
    });

    log('Waiting for connection...');

    // Logo image error handler (shows gradient fallback if logo fails)
    const splashLogo = document.getElementById('splash-logo');
    if (splashLogo) {
      splashLogo.addEventListener('error', () => {
        console.log('[Splash] Logo failed to load');
        splashLogo.style.display = 'none';
      });
    }

    // Debug: Log ambient photo slideshow state periodically
    setInterval(() => {
      const activePhoto = activePhotoElement === 1 ? photo1 : photo2;
      if (activePhoto && activePhoto.src) {
        console.log(`[Ambient Debug] Photo ${activePhotoElement} visible, index=${currentPhotoIndex}, src=${activePhoto.src.substring(0, 60)}...`);
      }
    }, 10000);
  </script>
</body>
</html>
