<!DOCTYPE html>
<html>
<head>
  <title>PC Nest Speaker - WebRTC Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <style>
    body { background: #334E58; margin: 0; padding: 0; }
    #status { color: #FCBFB7; font-family: sans-serif; font-size: 24px; text-align: center; padding-top: 40%; }
  </style>
</head>
<body>
  <cast-media-player></cast-media-player>
  <div id="status">PC Nest Speaker</div>
  <audio id="webrtc-audio" autoplay></audio>

  <script>
    const WEBRTC_NAMESPACE = 'urn:x-cast:com.pcnestspeaker.webrtc';

    // Cast framework setup
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const playbackConfig = new cast.framework.PlaybackConfig();

    // Low latency settings for HTTP fallback
    playbackConfig.autoResumeDuration = 0;
    playbackConfig.autoPauseDuration = 0;
    playbackConfig.initialBandwidth = 100000000;
    playbackConfig.disablePreload = true;
    playbackConfig.autoResumeNumberOfSegments = 0;
    playbackConfig.shakaConfig = {
      streaming: {
        bufferingGoal: 0.1,
        rebufferingGoal: 0,
        bufferBehind: 0,
        lowLatencyMode: true,
        segmentPrefetchLimit: 0,
        retryParameters: { maxAttempts: 1, timeout: 1000 }
      }
    };

    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.PRELOAD,
      () => null
    );

    playerManager.setPlaybackConfig(playbackConfig);

    // ===================
    // WebRTC via webrtc-streamer (based on official webrtcstreamer.js)
    // ===================
    let peerConnection = null;
    let webrtcStreamerUrl = null;
    let currentPeerId = null;
    let earlyCandidates = [];
    const audioElement = document.getElementById('webrtc-audio');

    function log(msg) {
      console.log('[WebRTC] ' + msg);
      document.getElementById('status').textContent = msg;
    }

    // Send ICE candidate to server (only if remote description is set)
    async function sendIceCandidate(candidate, serverUrl, peerId) {
      try {
        await fetch(serverUrl + '/api/addIceCandidate?peerid=' + encodeURIComponent(peerId), {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'bypass-tunnel-reminder': 'true'
          },
          body: JSON.stringify(candidate)
        });
      } catch (e) {
        console.error('Failed to send ICE candidate:', e);
      }
    }

    // Get server's ICE candidates and add them
    async function getServerIceCandidates(serverUrl, peerId) {
      try {
        const response = await fetch(serverUrl + '/api/getIceCandidate?peerid=' + encodeURIComponent(peerId), {
          headers: { 'bypass-tunnel-reminder': 'true' }
        });
        if (response.ok) {
          const candidates = await response.json();
          if (candidates && candidates.length) {
            log('Adding ' + candidates.length + ' server ICE candidates');
            for (const c of candidates) {
              await peerConnection.addIceCandidate(new RTCIceCandidate(c));
            }
          }
        }
      } catch (e) {
        console.error('Failed to get server ICE candidates:', e);
      }
    }

    /**
     * Connect to webrtc-streamer server
     * Based on official webrtcstreamer.js implementation
     */
    async function connectToWebRTCStreamer(serverUrl, streamName = 'pcaudio') {
      webrtcStreamerUrl = serverUrl;
      currentPeerId = '' + Math.random();  // Random peer ID like official lib
      earlyCandidates = [];
      log('Connecting to ' + serverUrl);

      // First get ICE servers from webrtc-streamer (like official lib)
      let iceConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
      try {
        const iceResponse = await fetch(serverUrl + '/api/getIceServers', {
          headers: { 'bypass-tunnel-reminder': 'true' }
        });
        if (iceResponse.ok) {
          iceConfig = await iceResponse.json();
          log('Got ICE servers from server');
        }
      } catch (e) {
        log('Using default STUN server');
      }

      peerConnection = new RTCPeerConnection(iceConfig);
      log('PeerConnection created, peerId: ' + currentPeerId);

      // Handle ICE candidates - send immediately if remote desc set, else queue
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          if (peerConnection.currentRemoteDescription) {
            // Remote description set - send immediately
            sendIceCandidate(event.candidate, serverUrl, currentPeerId);
          } else {
            // Queue for later
            earlyCandidates.push(event.candidate);
          }
        }
      };

      // Handle incoming audio track
      peerConnection.ontrack = (event) => {
        log('Audio track received!');
        if (event.streams && event.streams[0]) {
          audioElement.srcObject = event.streams[0];
          audioElement.play().then(() => {
            log('Playing - Low Latency!');
          }).catch(e => log('Play error: ' + e.message));
        }
      };

      peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        log('Connection: ' + state);
        if (state === 'connected') {
          log('Streaming - Sub-1s Latency!');
        } else if (state === 'failed') {
          log('Connection failed');
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        log('ICE: ' + peerConnection.iceConnectionState);
      };

      // Add transceiver to receive audio (recvonly)
      peerConnection.addTransceiver('audio', { direction: 'recvonly' });

      // Create SDP offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      log('Created offer');

      // Call webrtc-streamer API
      // Query the server to get the audio URL for the named stream, then use audiourl= parameter
      try {
        // First, get the stream configuration to find the audio device
        let audioUrl = 'audiocap://1'; // Default fallback
        try {
          const mediaListResp = await fetch(serverUrl + '/api/getMediaList', {
            headers: { 'bypass-tunnel-reminder': 'true' }
          });
          if (mediaListResp.ok) {
            const mediaList = await mediaListResp.json();
            log('Media list: ' + JSON.stringify(mediaList));
            // Check if our stream has a configured audio URL
            if (mediaList[streamName] && mediaList[streamName].audio) {
              audioUrl = mediaList[streamName].audio;
              log('Using configured audio: ' + audioUrl);
            }
          }
        } catch (e) {
          log('Using default audio device');
        }

        const callUrl = serverUrl + '/api/call?peerid=' + encodeURIComponent(currentPeerId) +
                        '&audiourl=' + encodeURIComponent(audioUrl) +
                        '&options=' + encodeURIComponent('rtptransport=tcp&timeout=60');

        log('Calling ' + callUrl);
        const response = await fetch(callUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'bypass-tunnel-reminder': 'true'
          },
          body: JSON.stringify(offer)
        });

        if (!response.ok) {
          throw new Error('Server returned ' + response.status);
        }

        const answer = await response.json();
        log('Got answer from server');

        // Set remote description
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        log('Set remote description');

        // Now send any early candidates that were queued
        while (earlyCandidates.length) {
          const candidate = earlyCandidates.shift();
          await sendIceCandidate(candidate, serverUrl, currentPeerId);
        }
        log('Sent early ICE candidates');

        // Get server's ICE candidates
        await getServerIceCandidates(serverUrl, currentPeerId);

      } catch (e) {
        log('Connection error: ' + e.message);
        console.error('WebRTC error:', e);
      }
    }

    function disconnect() {
      if (peerConnection) {
        // Hangup call on server
        if (webrtcStreamerUrl && currentPeerId) {
          fetch(webrtcStreamerUrl + '/api/hangup?peerid=' + encodeURIComponent(currentPeerId), {
            headers: { 'bypass-tunnel-reminder': 'true' }
          }).catch(() => {});
        }
        peerConnection.close();
        peerConnection = null;
        audioElement.srcObject = null;
        log('Disconnected');
      }
    }

    // Handle Cast messages (for starting/stopping WebRTC)
    function handleMessage(event) {
      log('Message: ' + JSON.stringify(event.data));
      const data = event.data;

      switch (data.type) {
        case 'connect':
          if (data.url) {
            connectToWebRTCStreamer(data.url, data.stream || 'pcaudio');
          } else {
            log('Error: No URL provided');
          }
          break;
        case 'disconnect':
        case 'close':
          disconnect();
          break;
        default:
          log('Unknown: ' + data.type);
      }
    }

    // Register custom message handler
    context.addCustomMessageListener(WEBRTC_NAMESPACE, handleMessage);

    // Start receiver
    context.start({
      playbackConfig: playbackConfig,
      skipPlayersLoad: false,
      disableIdleTimeout: true,
      supportedCommands: cast.framework.messages.Command.ALL_BASIC_MEDIA,
      customNamespaces: {
        [WEBRTC_NAMESPACE]: cast.framework.system.MessageType.JSON
      }
    });

    log('Ready - Waiting for URL...');

    // Listen for LOAD events with customData containing webrtc-streamer URL
    playerManager.addEventListener(
      cast.framework.events.EventType.LOAD_START,
      (event) => {
        log('Load event received');
        const loadRequestData = playerManager.getQueueManager().getItems()[0];
        if (loadRequestData && loadRequestData.media && loadRequestData.media.customData) {
          const customData = loadRequestData.media.customData;
          if (customData.webrtcUrl) {
            log('WebRTC URL from customData: ' + customData.webrtcUrl);
            playerManager.stop();
            connectToWebRTCStreamer(customData.webrtcUrl, customData.stream || 'pcaudio');
          }
        }
      }
    );

    // Also intercept LOAD to check customData before playback
    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (request) => {
        if (request.media && request.media.customData && request.media.customData.webrtcUrl) {
          log('WebRTC mode - URL: ' + request.media.customData.webrtcUrl);
          setTimeout(() => {
            connectToWebRTCStreamer(request.media.customData.webrtcUrl, request.media.customData.stream || 'pcaudio');
          }, 500);
          return null;
        }
        if (request.media) {
          request.media.streamType = cast.framework.messages.StreamType.LIVE;
          request.autoplay = true;
          request.currentTime = 0;
        }
        return request;
      }
    );
  </script>
</body>
</html>
